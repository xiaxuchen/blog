---
title: "Str"
date: 2024-03-02T16:22:13+08:00
draft: true
---

# 原地翻转字符串的所有单词
整个字符串翻转，然后每个单词单独翻转

# KMP算法
求next数组，一直不能理解，与以前的认知有些冲突了。
其实，next[i]一直表示都都是包括第i个字符的情况下的最长前后缀(**前后缀当然不能是整个字符串**)，这个是搞混的根源。
而我们回退的时候，当第i位匹配的时候，是回退到next[i - 1],因为当前的这个字符并不能并没有匹配，这个字符前面的都是匹配过的，通过前面字符的最长前缀，就能够进行回退(使得前后缀相匹配，比如ababa,在最后这个a不匹配，就可以回退到第二个a的位置去对比，因为ababa与原字符串匹配的是abab，只是最后这个a不匹配，所以移动到aba的时候，前面的ab和后面的ab重合，是完全匹配的)。
因此通过这个去判定重复字符串是可以的，即next[len - 1] + 1就是整个字符串的最大相等的前后缀，而如果总长度减去前后缀的长度的这个字符长度能被总长度求余，就说明是重复的，且重复字符串就是这剩下来的一截