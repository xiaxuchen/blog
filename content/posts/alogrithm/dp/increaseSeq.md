---
title: "IncreaseSeq"
date: 2024-02-14T16:16:25+08:00
draft: true
---

# 300.最长递增子序列

[力扣题目链接](https://leetcode.cn/problems/longest-increasing-subsequence/description/)
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：

    输入：nums = [10,9,2,5,3,7,101,18]
    输出：4
    解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2：

    输入：nums = [0,1,0,3,2,3]
    输出：4

示例 3：

    输入：nums = [7,7,7,7,7,7,7]
    输出：1

提示：

    1 <= nums.length <= 2500
    -10^4 <= nums[i] <= 104

## 思考

递增子序列依赖于前面序列的结尾元素，如果当前值大于结尾元素，那么就可以利用前面序列的累计值，从而基于子问题求解更大的问题。

而由于该题目是非连续的序列，因此当前值可能比前一个值小，但是也可能比前面的某一个值大，因此需要遍历前面所有的序列取最大。

# 674. 最长连续递增序列

[力扣题目链接](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/)
给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

示例 1：

    输入：nums = [1,3,5,4,7]
    输出：3
    解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。

示例 2：

    输入：nums = [2,2,2,2,2]
    输出：1
    解释：最长连续递增序列是 [2], 长度为1。

提示：

    0 <= nums.length <= 10^4
    -10^9 <= nums[i] <= 10^9

## 思路

由于这里是要求连续的，因此只会与前面一个数有依赖关系，因此能够得到递推公式。
即 dp[i] = dp[i - 1] + 1(if nums[i] > nums[i - 1])

# 718. 最长重复子数组

力扣题目链接

(opens new window)

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

示例：

输入：

    A: [1,2,3,2,1]
    B: [3,2,1,4,7]
    输出：3
    解释：长度最长的公共子数组是 [3, 2, 1] 。

提示：

    1 <= len(A), len(B) <= 1000
    0 <= A[i], B[i] < 100

## 思路

就是简单的，如果当前两个字符相等，那么他们可以基于前面的累计值+1
dp[i][j] = dp[i - 1][j - 1] + 1 (if nums[i - 1] == nums[j - 1])

# 1143.最长公共子序列

[力扣题目链接](https://leetcode.cn/problems/longest-common-subsequence/description/)

## 思考

与最长重复子数组一样，只是当前的长度可以有三个可能，

- 如果当前两个字符相等，那么就是两个前缀子串的长度 + 1
- 第一个子串往前一个字符，第二个不变
- 第二个子串往前一个字符，第一个不变

# 编辑距离
word1 = "horse", word2 = "ros"
dp[i][j]表示word1[0:i]转换为word2[0:j]的最少次数
dp[1][1] = 1 替换
dp[1][2] = dp[1][1] + 1 加1
如果i - 1 == j - 1
那么就可以dp[i - 1][j - 1]的变化
如果i - 1 != j - 1

# 

# 回文串
首先对于回文串，有其独特的性质，即回文串往外扩，两边相等仍是回文串，比如a -> bab两边b相等。而我们就是基于此。通过当前条件的比较，当前两个字符是否相等，如果相等，那么就看他们之间是否是回文串，以此进行判定。而子串和序列是不同的，序列表示可以从字符串中删除任意字符得到的序列，保持原来的顺序。